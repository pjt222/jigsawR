% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hexagonal_topology.R
\name{apply_hex_warp}
\alias{apply_hex_warp}
\title{Apply circular warp transformation to a point}
\usage{
apply_hex_warp(x, y)
}
\arguments{
\item{x}{X coordinate (relative to puzzle center at origin)}

\item{y}{Y coordinate (relative to puzzle center at origin)}
}
\value{
Named list with warped x, y coordinates
}
\description{
Transforms a point from hexagonal boundary space to circular boundary space.
Points on the hexagonal boundary are mapped to points on a circle of the same
"radius" (distance from center along the hexagonal boundary direction).
}
\details{
This is the inverse of what the original hex_warp does - it normalizes
the radial distance so that hexagonal boundary becomes circular.


The transformation matches the original hex_warp() from hexagonal_puzzle.R:
1. Calculates the angle from center to point (with +pi offset)
2. Determines the scale factor l at that angle
3. DIVIDES coordinates by l to push edge midpoints outward

For a point at angle θ, the scale factor is:
  l = sqrt(0.75) / cos(|30° - ((θ+180°) mod 60°)|)

The warped coordinates are: (x/l, y/l)

This maps a hexagonal grid onto a circle by:
- Keeping corners at same distance (l=1 at corners)
- Pushing edge midpoints outward (l<1 means divide increases distance)
}
\examples{
# At 0 degrees (hexagon edge midpoint): no change
edge_mid <- apply_hex_warp(50, 0)  # Returns same point

# At 30 degrees (between corner and edge): pushed outward
between <- apply_hex_warp(43.3, 25)
}
